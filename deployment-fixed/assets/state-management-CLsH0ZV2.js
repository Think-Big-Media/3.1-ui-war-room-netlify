var qt=Object.defineProperty;var Ct=(e,t,r)=>t in e?qt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r;var Ie=(e,t,r)=>(Ct(e,typeof t!="symbol"?t+"":t,r),r);import{e as ae,f as dt,h as Mt,k as It,l as De,n as ft,t as Qt,o as Tt,q as xe,u as ye,v as pt,x as ze,y as Dt,c as jt,z as Ve,B as ht,C as Ot,S as kt}from"./vendor-BRzv5eYZ.js";var _t=typeof window<"u"&&window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__?window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__:function(){if(arguments.length!==0)return typeof arguments[0]=="object"?De:De.apply(null,arguments)},xt=e=>e&&typeof e.match=="function";function V(e,t){function r(...s){if(t){let o=t(...s);if(!o)throw new Error(H(0));return{type:e,payload:o.payload,..."meta"in o&&{meta:o.meta},..."error"in o&&{error:o.error}}}return{type:e,payload:s[0]}}return r.toString=()=>`${e}`,r.type=e,r.match=s=>ft(s)&&s.type===e,r}var yt=class de extends Array{constructor(...t){super(...t),Object.setPrototypeOf(this,de.prototype)}static get[Symbol.species](){return de}concat(...t){return super.concat.apply(this,t)}prepend(...t){return t.length===1&&Array.isArray(t[0])?new de(...t[0].concat(this)):new de(...t.concat(this))}};function Le(e){return xe(e)?ye(e,()=>{}):e}function ve(e,t,r){return e.has(t)?e.get(t):e.set(t,r(t)).get(t)}function Ft(e){return typeof e=="boolean"}var Nt=()=>function(t){const{thunk:r=!0,immutableCheck:s=!0,serializableCheck:o=!0,actionCreatorCheck:b=!0}=t??{};let h=new yt;return r&&(Ft(r)?h.push(Qt):h.push(Tt(r.extraArgument))),h},Ae="RTK_autoBatch",ue=()=>e=>({payload:e,meta:{[Ae]:!0}}),He=e=>t=>{setTimeout(t,e)},$t=(e={type:"raf"})=>t=>(...r)=>{const s=t(...r);let o=!0,b=!1,h=!1;const E=new Set,S=e.type==="tick"?queueMicrotask:e.type==="raf"?typeof window<"u"&&window.requestAnimationFrame?window.requestAnimationFrame:He(10):e.type==="callback"?e.queueNotification:He(e.timeout),v=()=>{h=!1,b&&(b=!1,E.forEach(w=>w()))};return Object.assign({},s,{subscribe(w){const m=()=>o&&w(),u=s.subscribe(m);return E.add(w),()=>{u(),E.delete(w)}},dispatch(w){try{return o=!w?.meta?.[Ae],b=!o,b&&(h||(h=!0,S(v))),s.dispatch(w)}finally{o=!0}}})},Bt=e=>function(r){const{autoBatch:s=!0}=r??{};let o=new yt(e);return s&&o.push($t(typeof s=="object"?s:void 0)),o};function _n(e){const t=Nt(),{reducer:r=void 0,middleware:s,devTools:o=!0,duplicateMiddlewareCheck:b=!0,preloadedState:h=void 0,enhancers:E=void 0}=e||{};let S;if(typeof r=="function")S=r;else if(ae(r))S=dt(r);else throw new Error(H(1));let v;typeof s=="function"?v=s(t):v=t();let w=De;o&&(w=_t({trace:!1,...typeof o=="object"&&o}));const m=Mt(...v),u=Bt(m);let l=typeof E=="function"?E(u):u();const R=w(...l);return It(S,h,R)}function gt(e){const t={},r=[];let s;const o={addCase(b,h){const E=typeof b=="string"?b:b.type;if(!E)throw new Error(H(28));if(E in t)throw new Error(H(29));return t[E]=h,o},addMatcher(b,h){return r.push({matcher:b,reducer:h}),o},addDefaultCase(b){return s=b,o}};return e(o),[t,r,s]}function Ut(e){return typeof e=="function"}function Kt(e,t){let[r,s,o]=gt(t),b;if(Ut(e))b=()=>Le(e());else{const E=Le(e);b=()=>E}function h(E=b(),S){let v=[r[S.type],...s.filter(({matcher:w})=>w(S)).map(({reducer:w})=>w)];return v.filter(w=>!!w).length===0&&(v=[o]),v.reduce((w,m)=>{if(m)if(pt(w)){const l=m(w,S);return l===void 0?w:l}else{if(xe(w))return ye(w,u=>m(u,S));{const u=m(w,S);if(u===void 0){if(w===null)return w;throw Error("A case reducer on a non-draftable value must not return undefined")}return u}}return w},E)}return h.getInitialState=b,h}var mt=(e,t)=>xt(e)?e.match(t):e(t);function X(...e){return t=>e.some(r=>mt(r,t))}function fe(...e){return t=>e.every(r=>mt(r,t))}function Ee(e,t){if(!e||!e.meta)return!1;const r=typeof e.meta.requestId=="string",s=t.indexOf(e.meta.requestStatus)>-1;return r&&s}function ge(e){return typeof e[0]=="function"&&"pending"in e[0]&&"fulfilled"in e[0]&&"rejected"in e[0]}function Fe(...e){return e.length===0?t=>Ee(t,["pending"]):ge(e)?X(...e.map(t=>t.pending)):Fe()(e[0])}function ce(...e){return e.length===0?t=>Ee(t,["rejected"]):ge(e)?X(...e.map(t=>t.rejected)):ce()(e[0])}function qe(...e){const t=r=>r&&r.meta&&r.meta.rejectedWithValue;return e.length===0?fe(ce(...e),t):ge(e)?fe(ce(...e),t):qe()(e[0])}function ee(...e){return e.length===0?t=>Ee(t,["fulfilled"]):ge(e)?X(...e.map(t=>t.fulfilled)):ee()(e[0])}function je(...e){return e.length===0?t=>Ee(t,["pending","fulfilled","rejected"]):ge(e)?X(...e.flatMap(t=>[t.pending,t.rejected,t.fulfilled])):je()(e[0])}var Wt="ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW",Ne=(e=21)=>{let t="",r=e;for(;r--;)t+=Wt[Math.random()*64|0];return t},zt=["name","message","stack","code"],Qe=class{constructor(e,t){Ie(this,"_type");this.payload=e,this.meta=t}},Je=class{constructor(e,t){Ie(this,"_type");this.payload=e,this.meta=t}},Vt=e=>{if(typeof e=="object"&&e!==null){const t={};for(const r of zt)typeof e[r]=="string"&&(t[r]=e[r]);return t}return{message:String(e)}},Ge="External signal was aborted",Xe=(()=>{function e(t,r,s){const o=V(t+"/fulfilled",(S,v,w,m)=>({payload:S,meta:{...m||{},arg:w,requestId:v,requestStatus:"fulfilled"}})),b=V(t+"/pending",(S,v,w)=>({payload:void 0,meta:{...w||{},arg:v,requestId:S,requestStatus:"pending"}})),h=V(t+"/rejected",(S,v,w,m,u)=>({payload:m,error:(s&&s.serializeError||Vt)(S||"Rejected"),meta:{...u||{},arg:w,requestId:v,rejectedWithValue:!!m,requestStatus:"rejected",aborted:S?.name==="AbortError",condition:S?.name==="ConditionError"}}));function E(S,{signal:v}={}){return(w,m,u)=>{const l=s?.idGenerator?s.idGenerator(S):Ne(),R=new AbortController;let Q,C;function f(n){C=n,R.abort()}v&&(v.aborted?f(Ge):v.addEventListener("abort",()=>f(Ge),{once:!0}));const M=async function(){let n;try{let p=s?.condition?.(S,{getState:m,extra:u});if(Ht(p)&&(p=await p),p===!1||R.signal.aborted)throw{name:"ConditionError",message:"Aborted due to condition callback returning false."};const q=new Promise((P,I)=>{Q=()=>{I({name:"AbortError",message:C||"Aborted"})},R.signal.addEventListener("abort",Q)});w(b(l,S,s?.getPendingMeta?.({requestId:l,arg:S},{getState:m,extra:u}))),n=await Promise.race([q,Promise.resolve(r(S,{dispatch:w,getState:m,extra:u,requestId:l,signal:R.signal,abort:f,rejectWithValue:(P,I)=>new Qe(P,I),fulfillWithValue:(P,I)=>new Je(P,I)})).then(P=>{if(P instanceof Qe)throw P;return P instanceof Je?o(P.payload,l,S,P.meta):o(P,l,S)})])}catch(p){n=p instanceof Qe?h(null,l,S,p.payload,p.meta):h(p,l,S)}finally{Q&&R.signal.removeEventListener("abort",Q)}return s&&!s.dispatchConditionRejection&&h.match(n)&&n.meta.condition||w(n),n}();return Object.assign(M,{abort:f,requestId:l,arg:S,unwrap(){return M.then(Lt)}})}}return Object.assign(E,{pending:b,rejected:h,fulfilled:o,settled:X(h,o),typePrefix:t})}return e.withTypes=()=>e,e})();function Lt(e){if(e.meta&&e.meta.rejectedWithValue)throw e.payload;if(e.error)throw e.error;return e.payload}function Ht(e){return e!==null&&typeof e=="object"&&typeof e.then=="function"}var Jt=Symbol.for("rtk-slice-createasyncthunk");function Gt(e,t){return`${e}/${t}`}function Xt({creators:e}={}){const t=e?.asyncThunk?.[Jt];return function(s){const{name:o,reducerPath:b=o}=s;if(!o)throw new Error(H(11));typeof process<"u";const h=(typeof s.reducers=="function"?s.reducers(Zt()):s.reducers)||{},E=Object.keys(h),S={sliceCaseReducersByName:{},sliceCaseReducersByType:{},actionCreators:{},sliceMatchers:[]},v={addCase(n,a){const p=typeof n=="string"?n:n.type;if(!p)throw new Error(H(12));if(p in S.sliceCaseReducersByType)throw new Error(H(13));return S.sliceCaseReducersByType[p]=a,v},addMatcher(n,a){return S.sliceMatchers.push({matcher:n,reducer:a}),v},exposeAction(n,a){return S.actionCreators[n]=a,v},exposeCaseReducer(n,a){return S.sliceCaseReducersByName[n]=a,v}};E.forEach(n=>{const a=h[n],p={reducerName:n,type:Gt(o,n),createNotation:typeof s.reducers=="function"};tn(a)?rn(p,a,v,t):en(p,a,v)});function w(){const[n={},a=[],p=void 0]=typeof s.extraReducers=="function"?gt(s.extraReducers):[s.extraReducers],q={...n,...S.sliceCaseReducersByType};return Kt(s.initialState,P=>{for(let I in q)P.addCase(I,q[I]);for(let I of S.sliceMatchers)P.addMatcher(I.matcher,I.reducer);for(let I of a)P.addMatcher(I.matcher,I.reducer);p&&P.addDefaultCase(p)})}const m=n=>n,u=new Map,l=new WeakMap;let R;function Q(n,a){return R||(R=w()),R(n,a)}function C(){return R||(R=w()),R.getInitialState()}function f(n,a=!1){function p(P){let I=P[n];return typeof I>"u"&&a&&(I=ve(l,p,C)),I}function q(P=m){const I=ve(u,a,()=>new WeakMap);return ve(I,P,()=>{const A={};for(const[d,i]of Object.entries(s.selectors??{}))A[d]=Yt(i,P,()=>ve(l,P,C),a);return A})}return{reducerPath:n,getSelectors:q,get selectors(){return q(p)},selectSlice:p}}const M={name:o,reducer:Q,actions:S.actionCreators,caseReducers:S.sliceCaseReducersByName,getInitialState:C,...f(b),injectInto(n,{reducerPath:a,...p}={}){const q=a??b;return n.inject({reducerPath:q,reducer:Q},p),{...M,...f(q,!0)}}};return M}}function Yt(e,t,r,s){function o(b,...h){let E=t(b);return typeof E>"u"&&s&&(E=r()),e(E,...h)}return o.unwrapped=e,o}var se=Xt();function Zt(){function e(t,r){return{_reducerDefinitionType:"asyncThunk",payloadCreator:t,...r}}return e.withTypes=()=>e,{reducer(t){return Object.assign({[t.name](...r){return t(...r)}}[t.name],{_reducerDefinitionType:"reducer"})},preparedReducer(t,r){return{_reducerDefinitionType:"reducerWithPrepare",prepare:t,reducer:r}},asyncThunk:e}}function en({type:e,reducerName:t,createNotation:r},s,o){let b,h;if("reducer"in s){if(r&&!nn(s))throw new Error(H(17));b=s.reducer,h=s.prepare}else b=s;o.addCase(e,b).exposeCaseReducer(t,b).exposeAction(t,h?V(e,h):V(e))}function tn(e){return e._reducerDefinitionType==="asyncThunk"}function nn(e){return e._reducerDefinitionType==="reducerWithPrepare"}function rn({type:e,reducerName:t},r,s,o){if(!o)throw new Error(H(18));const{payloadCreator:b,fulfilled:h,pending:E,rejected:S,settled:v,options:w}=r,m=o(e,b,w);s.exposeAction(t,m),h&&s.addCase(m.fulfilled,h),E&&s.addCase(m.pending,E),S&&s.addCase(m.rejected,S),v&&s.addMatcher(m.settled,v),s.exposeCaseReducer(t,{fulfilled:h||be,pending:E||be,rejected:S||be,settled:v||be})}function be(){}function H(e){return`Minified Redux Toolkit error #${e}; visit https://redux-toolkit.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `}var sn=(e=>(e.uninitialized="uninitialized",e.pending="pending",e.fulfilled="fulfilled",e.rejected="rejected",e))(sn||{});function Ye(e){return{status:e,isUninitialized:e==="uninitialized",isLoading:e==="pending",isSuccess:e==="fulfilled",isError:e==="rejected"}}var Ze=ae;function vt(e,t){if(e===t||!(Ze(e)&&Ze(t)||Array.isArray(e)&&Array.isArray(t)))return t;const r=Object.keys(t),s=Object.keys(e);let o=r.length===s.length;const b=Array.isArray(t)?[]:{};for(const h of r)b[h]=vt(e[h],t[h]),o&&(o=e[h]===b[h]);return o?e:b}function oe(e){let t=0;for(const r in e)t++;return t}var et=e=>[].concat(...e);function on(e){return new RegExp("(^|:)//").test(e)}function an(){return typeof document>"u"?!0:document.visibilityState!=="hidden"}function Re(e){return e!=null}function cn(){return typeof navigator>"u"||navigator.onLine===void 0?!0:navigator.onLine}var un=e=>e.replace(/\/$/,""),ln=e=>e.replace(/^\//,"");function dn(e,t){if(!e)return t;if(!t)return e;if(on(t))return t;const r=e.endsWith("/")||!t.startsWith("?")?"/":"";return e=un(e),t=ln(t),`${e}${r}${t}`}function fn(e,t,r){return e.has(t)?e.get(t):e.set(t,r).get(t)}var tt=(...e)=>fetch(...e),pn=e=>e.status>=200&&e.status<=299,hn=e=>/ion\/(vnd\.api\+)?json/.test(e.get("content-type")||"");function nt(e){if(!ae(e))return e;const t={...e};for(const[r,s]of Object.entries(t))s===void 0&&delete t[r];return t}function xn({baseUrl:e,prepareHeaders:t=m=>m,fetchFn:r=tt,paramsSerializer:s,isJsonContentType:o=hn,jsonContentType:b="application/json",jsonReplacer:h,timeout:E,responseHandler:S,validateStatus:v,...w}={}){return typeof fetch>"u"&&r===tt&&console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments."),async(u,l,R)=>{const{getState:Q,extra:C,endpoint:f,forced:M,type:n}=l;let a,{url:p,headers:q=new Headers(w.headers),params:P=void 0,responseHandler:I=S??"json",validateStatus:A=v??pn,timeout:d=E,...i}=typeof u=="string"?{url:u}:u,c,y=l.signal;d&&(c=new AbortController,l.signal.addEventListener("abort",c.abort),y=c.signal);let g={...w,signal:y,...i};q=new Headers(nt(q)),g.headers=await t(q,{getState:Q,arg:u,extra:C,endpoint:f,forced:M,type:n,extraOptions:R})||q;const T=F=>typeof F=="object"&&(ae(F)||Array.isArray(F)||typeof F.toJSON=="function");if(!g.headers.has("content-type")&&T(g.body)&&g.headers.set("content-type",b),T(g.body)&&o(g.headers)&&(g.body=JSON.stringify(g.body,h)),P){const F=~p.indexOf("?")?"&":"?",j=s?s(P):new URLSearchParams(nt(P));p+=F+j}p=dn(e,p);const D=new Request(p,g);a={request:new Request(p,g)};let k,O=!1,x=c&&setTimeout(()=>{O=!0,c.abort()},d);try{k=await r(D)}catch(F){return{error:{status:O?"TIMEOUT_ERROR":"FETCH_ERROR",error:String(F)},meta:a}}finally{x&&clearTimeout(x),c?.signal.removeEventListener("abort",c.abort)}const K=k.clone();a.response=K;let W,U="";try{let F;if(await Promise.all([m(k,I).then(j=>W=j,j=>F=j),K.text().then(j=>U=j,()=>{})]),F)throw F}catch(F){return{error:{status:"PARSING_ERROR",originalStatus:k.status,data:U,error:String(F)},meta:a}}return A(k,W)?{data:W,meta:a}:{error:{status:k.status,data:W},meta:a}};async function m(u,l){if(typeof l=="function")return l(u);if(l==="content-type"&&(l=o(u.headers)?"json":"text"),l==="json"){const R=await u.text();return R.length?JSON.parse(R):null}return u.text()}}var rt=class{constructor(e,t=void 0){this.value=e,this.meta=t}},$e=V("__rtkq/focused"),bt=V("__rtkq/unfocused"),Be=V("__rtkq/online"),St=V("__rtkq/offline");function Ce(e){return e.type==="query"}function yn(e){return e.type==="mutation"}function Me(e){return e.type==="infinitequery"}function Pe(e){return Ce(e)||Me(e)}function Ue(e,t,r,s,o,b){return gn(e)?e(t,r,s,o).filter(Re).map(Oe).map(b):Array.isArray(e)?e.map(Oe).map(b):[]}function gn(e){return typeof e=="function"}function Oe(e){return typeof e=="string"?{type:e}:e}function mn(e,t){return e.catch(t)}var pe=Symbol("forceQueryFn"),ke=e=>typeof e[pe]=="function";function vn({serializeQueryArgs:e,queryThunk:t,infiniteQueryThunk:r,mutationThunk:s,api:o,context:b}){const h=new Map,E=new Map,{unsubscribeQueryResult:S,removeMutationResult:v,updateSubscriptionOptions:w}=o.internalActions;return{buildInitiateQuery:C,buildInitiateInfiniteQuery:f,buildInitiateMutation:M,getRunningQueryThunk:m,getRunningMutationThunk:u,getRunningQueriesThunk:l,getRunningMutationsThunk:R};function m(n,a){return p=>{const q=b.endpointDefinitions[n],P=e({queryArgs:a,endpointDefinition:q,endpointName:n});return h.get(p)?.[P]}}function u(n,a){return p=>E.get(p)?.[a]}function l(){return n=>Object.values(h.get(n)||{}).filter(Re)}function R(){return n=>Object.values(E.get(n)||{}).filter(Re)}function Q(n,a){const p=(q,{subscribe:P=!0,forceRefetch:I,subscriptionOptions:A,[pe]:d,...i}={})=>(c,y)=>{const g=e({queryArgs:q,endpointDefinition:a,endpointName:n});let T;const D={...i,type:"query",subscribe:P,forceRefetch:I,subscriptionOptions:A,endpointName:n,originalArgs:q,queryCacheKey:g,[pe]:d};if(Ce(a))T=t(D);else{const{direction:$,initialPageParam:J}=i;T=r({...D,direction:$,initialPageParam:J})}const _=o.endpoints[n].select(q),k=c(T),O=_(y()),{requestId:x,abort:K}=k,W=O.requestId!==x,U=h.get(c)?.[g],F=()=>_(y()),j=Object.assign(d?k.then(F):W&&!U?Promise.resolve(O):Promise.all([U,k]).then(F),{arg:q,requestId:x,subscriptionOptions:A,queryCacheKey:g,abort:K,async unwrap(){const $=await j;if($.isError)throw $.error;return $.data},refetch:()=>c(p(q,{subscribe:!1,forceRefetch:!0})),unsubscribe(){P&&c(S({queryCacheKey:g,requestId:x}))},updateSubscriptionOptions($){j.subscriptionOptions=$,c(w({endpointName:n,requestId:x,queryCacheKey:g,options:$}))}});if(!U&&!W&&!d){const $=fn(h,c,{});$[g]=j,j.then(()=>{delete $[g],oe($)||h.delete(c)})}return j};return p}function C(n,a){return Q(n,a)}function f(n,a){return Q(n,a)}function M(n){return(a,{track:p=!0,fixedCacheKey:q}={})=>(P,I)=>{const A=s({type:"mutation",endpointName:n,originalArgs:a,track:p,fixedCacheKey:q}),d=P(A),{requestId:i,abort:c,unwrap:y}=d,g=mn(d.unwrap().then(k=>({data:k})),k=>({error:k})),T=()=>{P(v({requestId:i,fixedCacheKey:q}))},D=Object.assign(g,{arg:d.arg,requestId:i,abort:c,unwrap:y,reset:T}),_=E.get(P)||{};return E.set(P,_),_[i]=D,D.then(()=>{delete _[i],oe(_)||E.delete(P)}),q&&(_[q]=D,D.then(()=>{_[q]===D&&(delete _[q],oe(_)||E.delete(P))})),D}}}var wt=class extends kt{constructor(e,t,r,s){super(e),this.value=t,this.schemaName=r,this._bqMeta=s}};async function te(e,t,r,s){const o=await e["~standard"].validate(t);if(o.issues)throw new wt(o.issues,t,r,s);return o.value}function bn(e){return e}var le=(e={})=>({...e,[Ae]:!0});function Sn({reducerPath:e,baseQuery:t,context:{endpointDefinitions:r},serializeQueryArgs:s,api:o,assertTagType:b,selectors:h,onSchemaFailure:E,catchSchemaFailure:S,skipSchemaValidation:v}){const w=(i,c,y,g)=>(T,D)=>{const _=r[i],k=s({queryArgs:c,endpointDefinition:_,endpointName:i});if(T(o.internalActions.queryResultPatched({queryCacheKey:k,patches:y})),!g)return;const O=o.endpoints[i].select(c)(D()),x=Ue(_.providesTags,O.data,void 0,c,{},b);T(o.internalActions.updateProvidedBy([{queryCacheKey:k,providedTags:x}]))};function m(i,c,y=0){const g=[c,...i];return y&&g.length>y?g.slice(0,-1):g}function u(i,c,y=0){const g=[...i,c];return y&&g.length>y?g.slice(1):g}const l=(i,c,y,g=!0)=>(T,D)=>{const k=o.endpoints[i].select(c)(D()),O={patches:[],inversePatches:[],undo:()=>T(o.util.patchQueryData(i,c,O.inversePatches,g))};if(k.status==="uninitialized")return O;let x;if("data"in k)if(xe(k.data)){const[K,W,U]=ht(k.data,y);O.patches.push(...W),O.inversePatches.push(...U),x=K}else x=y(k.data),O.patches.push({op:"replace",path:[],value:x}),O.inversePatches.push({op:"replace",path:[],value:k.data});return O.patches.length===0||T(o.util.patchQueryData(i,c,O.patches,g)),O},R=(i,c,y)=>g=>g(o.endpoints[i].initiate(c,{subscribe:!1,forceRefetch:!0,[pe]:()=>({data:y})})),Q=(i,c)=>i.query&&i[c]?i[c]:bn,C=async(i,{signal:c,abort:y,rejectWithValue:g,fulfillWithValue:T,dispatch:D,getState:_,extra:k})=>{const O=r[i.endpointName],{metaSchema:x,skipSchemaValidation:K=v}=O;try{let W=Q(O,"transformResponse");const U={signal:c,abort:y,dispatch:D,getState:_,extra:k,endpoint:i.endpointName,type:i.type,forced:i.type==="query"?f(i,_()):void 0,queryCacheKey:i.type==="query"?i.queryCacheKey:void 0},F=i.type==="query"?i[pe]:void 0;let j;const $=async(B,N,z,ne)=>{if(N==null&&B.pages.length)return Promise.resolve({data:B});const Y={queryArg:i.originalArgs,pageParam:N},re=await J(Y),L=ne?m:u;return{data:{pages:L(B.pages,re.data,z),pageParams:L(B.pageParams,N,z)},meta:re.meta}};async function J(B){let N;const{extraOptions:z,argSchema:ne,rawResponseSchema:Y,responseSchema:re}=O;if(ne&&!K&&(B=await te(ne,B,"argSchema",{})),F?N=F():O.query?N=await t(O.query(B),U,z):N=await O.queryFn(B,U,z,ie=>t(ie,U,z)),typeof process<"u",N.error)throw new rt(N.error,N.meta);let{data:L}=N;Y&&!K&&(L=await te(Y,N.data,"rawResponseSchema",N.meta));let Z=await W(L,N.meta,B);return re&&!K&&(Z=await te(re,Z,"responseSchema",N.meta)),{...N,data:Z}}if(i.type==="query"&&"infiniteQueryOptions"in O){const{infiniteQueryOptions:B}=O,{maxPages:N=1/0}=B;let z;const ne={pages:[],pageParams:[]},Y=h.selectQueryEntry(_(),i.queryCacheKey)?.data,L=f(i,_())&&!i.direction||!Y?ne:Y;if("direction"in i&&i.direction&&L.pages.length){const Z=i.direction==="backward",me=(Z?Rt:_e)(B,L,i.originalArgs);z=await $(L,me,N,Z)}else{const{initialPageParam:Z=B.initialPageParam}=i,ie=Y?.pageParams??[],me=ie[0]??Z,Ke=ie.length;z=await $(L,me,N),F&&(z={data:z.data.pages[0]});for(let We=1;We<Ke;We++){const Et=_e(B,z.data,i.originalArgs);z=await $(z.data,Et,N)}}j=z}else j=await J(i.originalArgs);return x&&!K&&j.meta&&(j.meta=await te(x,j.meta,"metaSchema",j.meta)),T(j.data,le({fulfilledTimeStamp:Date.now(),baseQueryMeta:j.meta}))}catch(W){let U=W;if(U instanceof rt){let F=Q(O,"transformErrorResponse");const{rawErrorResponseSchema:j,errorResponseSchema:$}=O;let{value:J,meta:B}=U;try{j&&!K&&(J=await te(j,J,"rawErrorResponseSchema",B)),x&&!K&&(B=await te(x,B,"metaSchema",B));let N=await F(J,B,i.originalArgs);return $&&!K&&(N=await te($,N,"errorResponseSchema",B)),g(N,le({baseQueryMeta:B}))}catch(N){U=N}}try{if(U instanceof wt){const F={endpoint:i.endpointName,arg:i.originalArgs,type:i.type,queryCacheKey:i.type==="query"?i.queryCacheKey:void 0};O.onSchemaFailure?.(U,F),E?.(U,F);const{catchSchemaFailure:j=S}=O;if(j)return g(j(U,F),le({baseQueryMeta:U._bqMeta}))}}catch(F){U=F}throw typeof process<"u",console.error(U),U}};function f(i,c){const y=h.selectQueryEntry(c,i.queryCacheKey),g=h.selectConfig(c).refetchOnMountOrArgChange,T=y?.fulfilledTimeStamp,D=i.forceRefetch??(i.subscribe&&g);return D?D===!0||(Number(new Date)-Number(T))/1e3>=D:!1}const M=()=>Xe(`${e}/executeQuery`,C,{getPendingMeta({arg:c}){const y=r[c.endpointName];return le({startedTimeStamp:Date.now(),...Me(y)?{direction:c.direction}:{}})},condition(c,{getState:y}){const g=y(),T=h.selectQueryEntry(g,c.queryCacheKey),D=T?.fulfilledTimeStamp,_=c.originalArgs,k=T?.originalArgs,O=r[c.endpointName],x=c.direction;return ke(c)?!0:T?.status==="pending"?!1:f(c,g)||Ce(O)&&O?.forceRefetch?.({currentArg:_,previousArg:k,endpointState:T,state:g})?!0:!(D&&!x)},dispatchConditionRejection:!0}),n=M(),a=M(),p=Xe(`${e}/executeMutation`,C,{getPendingMeta(){return le({startedTimeStamp:Date.now()})}}),q=i=>"force"in i,P=i=>"ifOlderThan"in i,I=(i,c,y)=>(g,T)=>{const D=q(y)&&y.force,_=P(y)&&y.ifOlderThan,k=(x=!0)=>{const K={forceRefetch:x,isPrefetch:!0};return o.endpoints[i].initiate(c,K)},O=o.endpoints[i].select(c)(T());if(D)g(k());else if(_){const x=O?.fulfilledTimeStamp;if(!x){g(k());return}(Number(new Date)-Number(new Date(x)))/1e3>=_&&g(k())}else g(k(!1))};function A(i){return c=>c?.meta?.arg?.endpointName===i}function d(i,c){return{matchPending:fe(Fe(i),A(c)),matchFulfilled:fe(ee(i),A(c)),matchRejected:fe(ce(i),A(c))}}return{queryThunk:n,mutationThunk:p,infiniteQueryThunk:a,prefetch:I,updateQueryData:l,upsertQueryData:R,patchQueryData:w,buildMatchThunkActions:d}}function _e(e,{pages:t,pageParams:r},s){const o=t.length-1;return e.getNextPageParam(t[o],t,r[o],r,s)}function Rt(e,{pages:t,pageParams:r},s){return e.getPreviousPageParam?.(t[0],t,r[0],r,s)}function Pt(e,t,r,s){return Ue(r[e.meta.arg.endpointName][t],ee(e)?e.payload:void 0,qe(e)?e.payload:void 0,e.meta.arg.originalArgs,"baseQueryMeta"in e.meta?e.meta.baseQueryMeta:void 0,s)}function Se(e,t,r){const s=e[t];s&&r(s)}function he(e){return("arg"in e?e.arg.fixedCacheKey:e.fixedCacheKey)??e.requestId}function it(e,t,r){const s=e[he(t)];s&&r(s)}var we={};function wn({reducerPath:e,queryThunk:t,mutationThunk:r,serializeQueryArgs:s,context:{endpointDefinitions:o,apiUid:b,extractRehydrationInfo:h,hasRehydrationInfo:E},assertTagType:S,config:v}){const w=V(`${e}/resetApiState`);function m(A,d,i,c){var y;A[y=d.queryCacheKey]??(A[y]={status:"uninitialized",endpointName:d.endpointName}),Se(A,d.queryCacheKey,g=>{g.status="pending",g.requestId=i&&g.requestId?g.requestId:c.requestId,d.originalArgs!==void 0&&(g.originalArgs=d.originalArgs),g.startedTimeStamp=c.startedTimeStamp;const T=o[c.arg.endpointName];Me(T)&&"direction"in d&&(g.direction=d.direction)})}function u(A,d,i,c){Se(A,d.arg.queryCacheKey,y=>{if(y.requestId!==d.requestId&&!c)return;const{merge:g}=o[d.arg.endpointName];if(y.status="fulfilled",g)if(y.data!==void 0){const{fulfilledTimeStamp:T,arg:D,baseQueryMeta:_,requestId:k}=d;let O=ye(y.data,x=>g(x,i,{arg:D.originalArgs,baseQueryMeta:_,fulfilledTimeStamp:T,requestId:k}));y.data=O}else y.data=i;else y.data=o[d.arg.endpointName].structuralSharing??!0?vt(pt(y.data)?Ot(y.data):y.data,i):i;delete y.error,y.fulfilledTimeStamp=d.fulfilledTimeStamp})}const l=se({name:`${e}/queries`,initialState:we,reducers:{removeQueryResult:{reducer(A,{payload:{queryCacheKey:d}}){delete A[d]},prepare:ue()},cacheEntriesUpserted:{reducer(A,d){for(const i of d.payload){const{queryDescription:c,value:y}=i;m(A,c,!0,{arg:c,requestId:d.meta.requestId,startedTimeStamp:d.meta.timestamp}),u(A,{arg:c,requestId:d.meta.requestId,fulfilledTimeStamp:d.meta.timestamp,baseQueryMeta:{}},y,!0)}},prepare:A=>({payload:A.map(c=>{const{endpointName:y,arg:g,value:T}=c,D=o[y];return{queryDescription:{type:"query",endpointName:y,originalArgs:c.arg,queryCacheKey:s({queryArgs:g,endpointDefinition:D,endpointName:y})},value:T}}),meta:{[Ae]:!0,requestId:Ne(),timestamp:Date.now()}})},queryResultPatched:{reducer(A,{payload:{queryCacheKey:d,patches:i}}){Se(A,d,c=>{c.data=Ve(c.data,i.concat())})},prepare:ue()}},extraReducers(A){A.addCase(t.pending,(d,{meta:i,meta:{arg:c}})=>{const y=ke(c);m(d,c,y,i)}).addCase(t.fulfilled,(d,{meta:i,payload:c})=>{const y=ke(i.arg);u(d,i,c,y)}).addCase(t.rejected,(d,{meta:{condition:i,arg:c,requestId:y},error:g,payload:T})=>{Se(d,c.queryCacheKey,D=>{if(!i){if(D.requestId!==y)return;D.status="rejected",D.error=T??g}})}).addMatcher(E,(d,i)=>{const{queries:c}=h(i);for(const[y,g]of Object.entries(c))(g?.status==="fulfilled"||g?.status==="rejected")&&(d[y]=g)})}}),R=se({name:`${e}/mutations`,initialState:we,reducers:{removeMutationResult:{reducer(A,{payload:d}){const i=he(d);i in A&&delete A[i]},prepare:ue()}},extraReducers(A){A.addCase(r.pending,(d,{meta:i,meta:{requestId:c,arg:y,startedTimeStamp:g}})=>{y.track&&(d[he(i)]={requestId:c,status:"pending",endpointName:y.endpointName,startedTimeStamp:g})}).addCase(r.fulfilled,(d,{payload:i,meta:c})=>{c.arg.track&&it(d,c,y=>{y.requestId===c.requestId&&(y.status="fulfilled",y.data=i,y.fulfilledTimeStamp=c.fulfilledTimeStamp)})}).addCase(r.rejected,(d,{payload:i,error:c,meta:y})=>{y.arg.track&&it(d,y,g=>{g.requestId===y.requestId&&(g.status="rejected",g.error=i??c)})}).addMatcher(E,(d,i)=>{const{mutations:c}=h(i);for(const[y,g]of Object.entries(c))(g?.status==="fulfilled"||g?.status==="rejected")&&y!==g?.requestId&&(d[y]=g)})}}),Q={tags:{},keys:{}},C=se({name:`${e}/invalidation`,initialState:Q,reducers:{updateProvidedBy:{reducer(A,d){var i,c,y;for(const{queryCacheKey:g,providedTags:T}of d.payload){f(A,g);for(const{type:D,id:_}of T){const k=(c=(i=A.tags)[D]??(i[D]={}))[y=_||"__internal_without_id"]??(c[y]=[]);k.includes(g)||k.push(g)}A.keys[g]=T}},prepare:ue()}},extraReducers(A){A.addCase(l.actions.removeQueryResult,(d,{payload:{queryCacheKey:i}})=>{f(d,i)}).addMatcher(E,(d,i)=>{var y,g,T;const{provided:c}=h(i);for(const[D,_]of Object.entries(c))for(const[k,O]of Object.entries(_)){const x=(g=(y=d.tags)[D]??(y[D]={}))[T=k||"__internal_without_id"]??(g[T]=[]);for(const K of O)x.includes(K)||x.push(K)}}).addMatcher(X(ee(t),qe(t)),(d,i)=>{M(d,[i])}).addMatcher(l.actions.cacheEntriesUpserted.match,(d,i)=>{const c=i.payload.map(({queryDescription:y,value:g})=>({type:"UNKNOWN",payload:g,meta:{requestStatus:"fulfilled",requestId:"UNKNOWN",arg:y}}));M(d,c)})}});function f(A,d){const i=A.keys[d]??[];for(const c of i){const y=c.type,g=c.id??"__internal_without_id",T=A.tags[y]?.[g];T&&(A.tags[y][g]=T.filter(D=>D!==d))}delete A.keys[d]}function M(A,d){const i=d.map(c=>{const y=Pt(c,"providesTags",o,S),{queryCacheKey:g}=c.meta.arg;return{queryCacheKey:g,providedTags:y}});C.caseReducers.updateProvidedBy(A,C.actions.updateProvidedBy(i))}const n=se({name:`${e}/subscriptions`,initialState:we,reducers:{updateSubscriptionOptions(A,d){},unsubscribeQueryResult(A,d){},internal_getRTKQSubscriptions(){}}}),a=se({name:`${e}/internalSubscriptions`,initialState:we,reducers:{subscriptionsUpdated:{reducer(A,d){return Ve(A,d.payload)},prepare:ue()}}}),p=se({name:`${e}/config`,initialState:{online:cn(),focused:an(),middlewareRegistered:!1,...v},reducers:{middlewareRegistered(A,{payload:d}){A.middlewareRegistered=A.middlewareRegistered==="conflict"||b!==d?"conflict":!0}},extraReducers:A=>{A.addCase(Be,d=>{d.online=!0}).addCase(St,d=>{d.online=!1}).addCase($e,d=>{d.focused=!0}).addCase(bt,d=>{d.focused=!1}).addMatcher(E,d=>({...d}))}}),q=dt({queries:l.reducer,mutations:R.reducer,provided:C.reducer,subscriptions:a.reducer,config:p.reducer}),P=(A,d)=>q(w.match(d)?void 0:A,d),I={...p.actions,...l.actions,...n.actions,...a.actions,...R.actions,...C.actions,resetApiState:w};return{reducer:P,actions:I}}var Te=Symbol.for("RTKQ/skipToken"),At={status:"uninitialized"},st=ye(At,()=>{}),ot=ye(At,()=>{});function Rn({serializeQueryArgs:e,reducerPath:t,createSelector:r}){const s=n=>st,o=n=>ot;return{buildQuerySelector:u,buildInfiniteQuerySelector:l,buildMutationSelector:R,selectInvalidatedBy:Q,selectCachedArgsForQuery:C,selectApiState:h,selectQueries:E,selectMutations:v,selectQueryEntry:S,selectConfig:w};function b(n){return{...n,...Ye(n.status)}}function h(n){return n[t]}function E(n){return h(n)?.queries}function S(n,a){return E(n)?.[a]}function v(n){return h(n)?.mutations}function w(n){return h(n)?.config}function m(n,a,p){return q=>{if(q===Te)return r(s,p);const P=e({queryArgs:q,endpointDefinition:a,endpointName:n});return r(A=>S(A,P)??st,p)}}function u(n,a){return m(n,a,b)}function l(n,a){const{infiniteQueryOptions:p}=a;function q(P){const I={...P,...Ye(P.status)},{isLoading:A,isError:d,direction:i}=I,c=i==="forward",y=i==="backward";return{...I,hasNextPage:f(p,I.data,I.originalArgs),hasPreviousPage:M(p,I.data,I.originalArgs),isFetchingNextPage:A&&c,isFetchingPreviousPage:A&&y,isFetchNextPageError:d&&c,isFetchPreviousPageError:d&&y}}return m(n,a,q)}function R(){return n=>{let a;return typeof n=="object"?a=he(n)??Te:a=n,r(a===Te?o:P=>h(P)?.mutations?.[a]??ot,b)}}function Q(n,a){const p=n[t],q=new Set;for(const P of a.filter(Re).map(Oe)){const I=p.provided.tags[P.type];if(!I)continue;let A=(P.id!==void 0?I[P.id]:et(Object.values(I)))??[];for(const d of A)q.add(d)}return et(Array.from(q.values()).map(P=>{const I=p.queries[P];return I?[{queryCacheKey:P,endpointName:I.endpointName,originalArgs:I.originalArgs}]:[]}))}function C(n,a){return Object.values(E(n)).filter(p=>p?.endpointName===a&&p.status!=="uninitialized").map(p=>p.originalArgs)}function f(n,a,p){return a?_e(n,a,p)!=null:!1}function M(n,a,p){return!a||!n.getPreviousPageParam?!1:Rt(n,a,p)!=null}}var at=WeakMap?new WeakMap:void 0,ct=({endpointName:e,queryArgs:t})=>{let r="";const s=at?.get(t);if(typeof s=="string")r=s;else{const o=JSON.stringify(t,(b,h)=>(h=typeof h=="bigint"?{$bigint:h.toString()}:h,h=ae(h)?Object.keys(h).sort().reduce((E,S)=>(E[S]=h[S],E),{}):h,h));ae(t)&&at?.set(t,o),r=o}return`${e}(${r})`};function Fn(...e){return function(r){const s=ze(v=>r.extractRehydrationInfo?.(v,{reducerPath:r.reducerPath??"api"})),o={reducerPath:"api",keepUnusedDataFor:60,refetchOnMountOrArgChange:!1,refetchOnFocus:!1,refetchOnReconnect:!1,invalidationBehavior:"delayed",...r,extractRehydrationInfo:s,serializeQueryArgs(v){let w=ct;if("serializeQueryArgs"in v.endpointDefinition){const m=v.endpointDefinition.serializeQueryArgs;w=u=>{const l=m(u);return typeof l=="string"?l:ct({...u,queryArgs:l})}}else r.serializeQueryArgs&&(w=r.serializeQueryArgs);return w(v)},tagTypes:[...r.tagTypes||[]]},b={endpointDefinitions:{},batch(v){v()},apiUid:Ne(),extractRehydrationInfo:s,hasRehydrationInfo:ze(v=>s(v)!=null)},h={injectEndpoints:S,enhanceEndpoints({addTagTypes:v,endpoints:w}){if(v)for(const m of v)o.tagTypes.includes(m)||o.tagTypes.push(m);if(w)for(const[m,u]of Object.entries(w))typeof u=="function"?u(b.endpointDefinitions[m]):Object.assign(b.endpointDefinitions[m]||{},u);return h}},E=e.map(v=>v.init(h,o,b));function S(v){const w=v.endpoints({query:m=>({...m,type:"query"}),mutation:m=>({...m,type:"mutation"}),infiniteQuery:m=>({...m,type:"infinitequery"})});for(const[m,u]of Object.entries(w)){if(v.overrideExisting!==!0&&m in b.endpointDefinitions){if(v.overrideExisting==="throw")throw new Error(H(39));typeof process<"u";continue}typeof process<"u",b.endpointDefinitions[m]=u;for(const l of E)l.injectEndpoint(m,u)}return h}return h.injectEndpoints({endpoints:r.endpoints})}}function G(e,...t){return Object.assign(e,...t)}var Pn=({api:e,queryThunk:t,internalState:r})=>{const s=`${e.reducerPath}/subscriptions`;let o=null,b=null;const{updateSubscriptionOptions:h,unsubscribeQueryResult:E}=e.internalActions,S=(l,R)=>{var C,f;if(h.match(R)){const{queryCacheKey:M,requestId:n,options:a}=R.payload;return l?.[M]?.[n]&&(l[M][n]=a),!0}if(E.match(R)){const{queryCacheKey:M,requestId:n}=R.payload;return l[M]&&delete l[M][n],!0}if(e.internalActions.removeQueryResult.match(R))return delete l[R.payload.queryCacheKey],!0;if(t.pending.match(R)){const{meta:{arg:M,requestId:n}}=R,a=l[C=M.queryCacheKey]??(l[C]={});return a[`${n}_running`]={},M.subscribe&&(a[n]=M.subscriptionOptions??a[n]??{}),!0}let Q=!1;if(t.fulfilled.match(R)||t.rejected.match(R)){const M=l[R.meta.arg.queryCacheKey]||{},n=`${R.meta.requestId}_running`;Q||(Q=!!M[n]),delete M[n]}if(t.rejected.match(R)){const{meta:{condition:M,arg:n,requestId:a}}=R;if(M&&n.subscribe){const p=l[f=n.queryCacheKey]??(l[f]={});p[a]=n.subscriptionOptions??p[a]??{},Q=!0}}return Q},v=()=>r.currentSubscriptions,u={getSubscriptions:v,getSubscriptionCount:l=>{const Q=v()[l]??{};return oe(Q)},isRequestSubscribed:(l,R)=>!!v()?.[l]?.[R]};return(l,R)=>{if(o||(o=JSON.parse(JSON.stringify(r.currentSubscriptions))),e.util.resetApiState.match(l))return o=r.currentSubscriptions={},b=null,[!0,!1];if(e.internalActions.internal_getRTKQSubscriptions.match(l))return[!1,u];const Q=S(r.currentSubscriptions,l);let C=!0;if(Q){b||(b=setTimeout(()=>{const n=JSON.parse(JSON.stringify(r.currentSubscriptions)),[,a]=ht(o,()=>n);R.next(e.internalActions.subscriptionsUpdated(a)),o=n,b=null},500));const f=typeof l.type=="string"&&!!l.type.startsWith(s),M=t.rejected.match(l)&&l.meta.condition&&!!l.meta.arg.subscribe;C=!f&&!M}return[C,!1]}};function An(e){for(const t in e)return!1;return!0}var En=2147483647/1e3-1,qn=({reducerPath:e,api:t,queryThunk:r,context:s,internalState:o,selectors:{selectQueryEntry:b,selectConfig:h}})=>{const{removeQueryResult:E,unsubscribeQueryResult:S,cacheEntriesUpserted:v}=t.internalActions,w=X(S.match,r.fulfilled,r.rejected,v.match);function m(C){const f=o.currentSubscriptions[C];return!!f&&!An(f)}const u={},l=(C,f,M)=>{const n=f.getState(),a=h(n);if(w(C)){let p;if(v.match(C))p=C.payload.map(q=>q.queryDescription.queryCacheKey);else{const{queryCacheKey:q}=S.match(C)?C.payload:C.meta.arg;p=[q]}R(p,f,a)}if(t.util.resetApiState.match(C))for(const[p,q]of Object.entries(u))q&&clearTimeout(q),delete u[p];if(s.hasRehydrationInfo(C)){const{queries:p}=s.extractRehydrationInfo(C);R(Object.keys(p),f,a)}};function R(C,f,M){const n=f.getState();for(const a of C){const p=b(n,a);Q(a,p?.endpointName,f,M)}}function Q(C,f,M,n){const p=s.endpointDefinitions[f]?.keepUnusedDataFor??n.keepUnusedDataFor;if(p===1/0)return;const q=Math.max(0,Math.min(p,En));if(!m(C)){const P=u[C];P&&clearTimeout(P),u[C]=setTimeout(()=>{m(C)||M.dispatch(E({queryCacheKey:C})),delete u[C]},q*1e3)}}return l},ut=new Error("Promise never resolved before cacheEntryRemoved."),Cn=({api:e,reducerPath:t,context:r,queryThunk:s,mutationThunk:o,internalState:b,selectors:{selectQueryEntry:h,selectApiState:E}})=>{const S=je(s),v=je(o),w=ee(s,o),m={};function u(f,M,n){const a=m[f];a?.valueResolved&&(a.valueResolved({data:M,meta:n}),delete a.valueResolved)}function l(f){const M=m[f];M&&(delete m[f],M.cacheEntryRemoved())}const R=(f,M,n)=>{const a=Q(f);function p(q,P,I,A){const d=h(n,P),i=h(M.getState(),P);!d&&i&&C(q,A,P,M,I)}if(s.pending.match(f))p(f.meta.arg.endpointName,a,f.meta.requestId,f.meta.arg.originalArgs);else if(e.internalActions.cacheEntriesUpserted.match(f))for(const{queryDescription:q,value:P}of f.payload){const{endpointName:I,originalArgs:A,queryCacheKey:d}=q;p(I,d,f.meta.requestId,A),u(d,P,{})}else if(o.pending.match(f))M.getState()[t].mutations[a]&&C(f.meta.arg.endpointName,f.meta.arg.originalArgs,a,M,f.meta.requestId);else if(w(f))u(a,f.payload,f.meta.baseQueryMeta);else if(e.internalActions.removeQueryResult.match(f)||e.internalActions.removeMutationResult.match(f))l(a);else if(e.util.resetApiState.match(f))for(const q of Object.keys(m))l(q)};function Q(f){return S(f)?f.meta.arg.queryCacheKey:v(f)?f.meta.arg.fixedCacheKey??f.meta.requestId:e.internalActions.removeQueryResult.match(f)?f.payload.queryCacheKey:e.internalActions.removeMutationResult.match(f)?he(f.payload):""}function C(f,M,n,a,p){const q=r.endpointDefinitions[f],P=q?.onCacheEntryAdded;if(!P)return;const I={},A=new Promise(T=>{I.cacheEntryRemoved=T}),d=Promise.race([new Promise(T=>{I.valueResolved=T}),A.then(()=>{throw ut})]);d.catch(()=>{}),m[n]=I;const i=e.endpoints[f].select(Pe(q)?M:n),c=a.dispatch((T,D,_)=>_),y={...a,getCacheEntry:()=>i(a.getState()),requestId:p,extra:c,updateCachedData:Pe(q)?T=>a.dispatch(e.util.updateQueryData(f,M,T)):void 0,cacheDataLoaded:d,cacheEntryRemoved:A},g=P(M,y);Promise.resolve(g).catch(T=>{if(T!==ut)throw T})}return R},Mn=({api:e,context:{apiUid:t},reducerPath:r})=>(s,o)=>{e.util.resetApiState.match(s)&&o.dispatch(e.internalActions.middlewareRegistered(t)),typeof process<"u"},In=({reducerPath:e,context:t,context:{endpointDefinitions:r},mutationThunk:s,queryThunk:o,api:b,assertTagType:h,refetchQuery:E,internalState:S})=>{const{removeQueryResult:v}=b.internalActions,w=X(ee(s),qe(s)),m=X(ee(s,o),ce(s,o));let u=[];const l=(C,f)=>{w(C)?Q(Pt(C,"invalidatesTags",r,h),f):m(C)?Q([],f):b.util.invalidateTags.match(C)&&Q(Ue(C.payload,void 0,void 0,void 0,void 0,h),f)};function R(C){const{queries:f,mutations:M}=C;for(const n of[f,M])for(const a in n)if(n[a]?.status==="pending")return!0;return!1}function Q(C,f){const M=f.getState(),n=M[e];if(u.push(...C),n.config.invalidationBehavior==="delayed"&&R(n))return;const a=u;if(u=[],a.length===0)return;const p=b.util.selectInvalidatedBy(M,a);t.batch(()=>{const q=Array.from(p.values());for(const{queryCacheKey:P}of q){const I=n.queries[P],A=S.currentSubscriptions[P]??{};I&&(oe(A)===0?f.dispatch(v({queryCacheKey:P})):I.status!=="uninitialized"&&f.dispatch(E(I)))}})}return l},Qn=({reducerPath:e,queryThunk:t,api:r,refetchQuery:s,internalState:o})=>{const b={},h=(u,l)=>{(r.internalActions.updateSubscriptionOptions.match(u)||r.internalActions.unsubscribeQueryResult.match(u))&&S(u.payload,l),(t.pending.match(u)||t.rejected.match(u)&&u.meta.condition)&&S(u.meta.arg,l),(t.fulfilled.match(u)||t.rejected.match(u)&&!u.meta.condition)&&E(u.meta.arg,l),r.util.resetApiState.match(u)&&w()};function E({queryCacheKey:u},l){const R=l.getState()[e],Q=R.queries[u],C=o.currentSubscriptions[u];if(!Q||Q.status==="uninitialized")return;const{lowestPollingInterval:f,skipPollingIfUnfocused:M}=m(C);if(!Number.isFinite(f))return;const n=b[u];n?.timeout&&(clearTimeout(n.timeout),n.timeout=void 0);const a=Date.now()+f;b[u]={nextPollTimestamp:a,pollingInterval:f,timeout:setTimeout(()=>{(R.config.focused||!M)&&l.dispatch(s(Q)),E({queryCacheKey:u},l)},f)}}function S({queryCacheKey:u},l){const Q=l.getState()[e].queries[u],C=o.currentSubscriptions[u];if(!Q||Q.status==="uninitialized")return;const{lowestPollingInterval:f}=m(C);if(!Number.isFinite(f)){v(u);return}const M=b[u],n=Date.now()+f;(!M||n<M.nextPollTimestamp)&&E({queryCacheKey:u},l)}function v(u){const l=b[u];l?.timeout&&clearTimeout(l.timeout),delete b[u]}function w(){for(const u of Object.keys(b))v(u)}function m(u={}){let l=!1,R=Number.POSITIVE_INFINITY;for(let Q in u)u[Q].pollingInterval&&(R=Math.min(u[Q].pollingInterval,R),l=u[Q].skipPollingIfUnfocused||l);return{lowestPollingInterval:R,skipPollingIfUnfocused:l}}return h},Tn=({api:e,context:t,queryThunk:r,mutationThunk:s})=>{const o=Fe(r,s),b=ce(r,s),h=ee(r,s),E={};return(v,w)=>{if(o(v)){const{requestId:m,arg:{endpointName:u,originalArgs:l}}=v.meta,R=t.endpointDefinitions[u],Q=R?.onQueryStarted;if(Q){const C={},f=new Promise((p,q)=>{C.resolve=p,C.reject=q});f.catch(()=>{}),E[m]=C;const M=e.endpoints[u].select(Pe(R)?l:m),n=w.dispatch((p,q,P)=>P),a={...w,getCacheEntry:()=>M(w.getState()),requestId:m,extra:n,updateCachedData:Pe(R)?p=>w.dispatch(e.util.updateQueryData(u,l,p)):void 0,queryFulfilled:f};Q(l,a)}}else if(h(v)){const{requestId:m,baseQueryMeta:u}=v.meta;E[m]?.resolve({data:v.payload,meta:u}),delete E[m]}else if(b(v)){const{requestId:m,rejectedWithValue:u,baseQueryMeta:l}=v.meta;E[m]?.reject({error:v.payload??v.error,isUnhandledError:!u,meta:l}),delete E[m]}}},Dn=({reducerPath:e,context:t,api:r,refetchQuery:s,internalState:o})=>{const{removeQueryResult:b}=r.internalActions,h=(S,v)=>{$e.match(S)&&E(v,"refetchOnFocus"),Be.match(S)&&E(v,"refetchOnReconnect")};function E(S,v){const w=S.getState()[e],m=w.queries,u=o.currentSubscriptions;t.batch(()=>{for(const l of Object.keys(u)){const R=m[l],Q=u[l];if(!Q||!R)continue;(Object.values(Q).some(f=>f[v]===!0)||Object.values(Q).every(f=>f[v]===void 0)&&w.config[v])&&(oe(Q)===0?S.dispatch(b({queryCacheKey:l})):R.status!=="uninitialized"&&S.dispatch(s(R)))}})}return h};function jn(e){const{reducerPath:t,queryThunk:r,api:s,context:o}=e,{apiUid:b}=o,h={invalidateTags:V(`${t}/invalidateTags`)},E=m=>m.type.startsWith(`${t}/`),S=[Mn,qn,In,Qn,Cn,Tn];return{middleware:m=>{let u=!1;const R={...e,internalState:{currentSubscriptions:{}},refetchQuery:w,isThisApiSliceAction:E},Q=S.map(M=>M(R)),C=Pn(R),f=Dn(R);return M=>n=>{if(!ft(n))return M(n);u||(u=!0,m.dispatch(s.internalActions.middlewareRegistered(b)));const a={...m,next:M},p=m.getState(),[q,P]=C(n,a,p);let I;if(q?I=M(n):I=P,m.getState()[t]&&(f(n,a,p),E(n)||o.hasRehydrationInfo(n)))for(const A of Q)A(n,a,p);return I}},actions:h};function w(m){return e.api.endpoints[m.endpointName].initiate(m.originalArgs,{subscribe:!1,forceRefetch:!0})}}var lt=Symbol(),Nn=({createSelector:e=jt}={})=>({name:lt,init(t,{baseQuery:r,tagTypes:s,reducerPath:o,serializeQueryArgs:b,keepUnusedDataFor:h,refetchOnMountOrArgChange:E,refetchOnFocus:S,refetchOnReconnect:v,invalidationBehavior:w,onSchemaFailure:m,catchSchemaFailure:u,skipSchemaValidation:l},R){Dt();const Q=j=>(typeof process<"u",j);Object.assign(t,{reducerPath:o,endpoints:{},internalActions:{onOnline:Be,onOffline:St,onFocus:$e,onFocusLost:bt},util:{}});const C=Rn({serializeQueryArgs:b,reducerPath:o,createSelector:e}),{selectInvalidatedBy:f,selectCachedArgsForQuery:M,buildQuerySelector:n,buildInfiniteQuerySelector:a,buildMutationSelector:p}=C;G(t.util,{selectInvalidatedBy:f,selectCachedArgsForQuery:M});const{queryThunk:q,infiniteQueryThunk:P,mutationThunk:I,patchQueryData:A,updateQueryData:d,upsertQueryData:i,prefetch:c,buildMatchThunkActions:y}=Sn({baseQuery:r,reducerPath:o,context:R,api:t,serializeQueryArgs:b,assertTagType:Q,selectors:C,onSchemaFailure:m,catchSchemaFailure:u,skipSchemaValidation:l}),{reducer:g,actions:T}=wn({context:R,queryThunk:q,infiniteQueryThunk:P,mutationThunk:I,serializeQueryArgs:b,reducerPath:o,assertTagType:Q,config:{refetchOnFocus:S,refetchOnReconnect:v,refetchOnMountOrArgChange:E,keepUnusedDataFor:h,reducerPath:o,invalidationBehavior:w}});G(t.util,{patchQueryData:A,updateQueryData:d,upsertQueryData:i,prefetch:c,resetApiState:T.resetApiState,upsertQueryEntries:T.cacheEntriesUpserted}),G(t.internalActions,T);const{middleware:D,actions:_}=jn({reducerPath:o,context:R,queryThunk:q,mutationThunk:I,infiniteQueryThunk:P,api:t,assertTagType:Q,selectors:C});G(t.util,_),G(t,{reducer:g,middleware:D});const{buildInitiateQuery:k,buildInitiateInfiniteQuery:O,buildInitiateMutation:x,getRunningMutationThunk:K,getRunningMutationsThunk:W,getRunningQueriesThunk:U,getRunningQueryThunk:F}=vn({queryThunk:q,mutationThunk:I,infiniteQueryThunk:P,api:t,serializeQueryArgs:b,context:R});return G(t.util,{getRunningMutationThunk:K,getRunningMutationsThunk:W,getRunningQueryThunk:F,getRunningQueriesThunk:U}),{name:lt,injectEndpoint(j,$){var N;const B=(N=t.endpoints)[j]??(N[j]={});Ce($)&&G(B,{name:j,select:n(j,$),initiate:k(j,$)},y(q,j)),yn($)&&G(B,{name:j,select:p(),initiate:x(j)},y(I,j)),Me($)&&G(B,{name:j,select:a(j,$),initiate:O(j,$)},y(q,j))}}}});export{sn as Q,xn as a,Fn as b,Nn as c,ct as d,se as e,H as f,_n as g,Te as s};
